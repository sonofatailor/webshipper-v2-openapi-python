# coding: utf-8

"""
    Webshipper V2 REST API

       <p>     The Webshipper API is a RESTful JSON API that gives full control over your Webshipper account. The API is scoped to your <em>account name</em>,     and is accessed via the endpoint <em>https://&lt;account name&gt;.api.webshipper.io/v2/</em>. Your <em>account name</em> is the same as you see when you access the Webshipper web UI     at <em>https://&lt;account name&gt;.webshipper.io</em>.   </p>    <p>     This API conforms to the <a href=\"http://jsonapi.org/\">JSON API standard</a> with the following conventions:     <ul>       <li>Resources are identified with the attribute <code>id</code>, which is a server-side generated sequential integer</li>       <li>Resource types are pluralised and underscored, like <code>order_lines</code></li>       <li>The API has a fixed page limit of 30 records. To fetch more records use the query parameter <code>page[number]</code></li>       <li>All resources have the attributes <code>created_at</code> and <code>updated_at</code> which are ISO 8601 timestamps like <code>2018-03-07T14:01:18.000Z</code> </li>       <li>All country codes are <a href=\"https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\">ISO 3166-1 alpha-2</a> codes</li>     </ul>   </p>     <p> It is also possible to download the documentation in the OpenAPI 3.0 <a href=\"?download_openapi=1\">here</a> </p>    <div class=\"alert alert-info\">     <i class=\"fa fa-info mr-2\"></i>     Webshipper <em>strongly</em> recommends using a client library for utilising this API. Refer to jsonapi.org's list of     <a href=\"http://jsonapi.org/implementations/#client-libraries\">jsonapi.org's list of client libraries</a> to find one for your language.   </div> 

    The version of the OpenAPI document: 1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
from pydantic import Field
from openapi_client.models.drop_points import DropPoints
from openapi_client.models.order_lines import OrderLines
from openapi_client.models.shipping_addresses import ShippingAddresses
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class Orders(BaseModel):
    """
    Orders
    """ # noqa: E501
    order_channel_id: Optional[StrictInt] = Field(default=None, description="DEPRECATED Assign a relation instead")
    status: Optional[StrictStr] = Field(default=None, description="Enum status of the order. Possible values: pending, dispatched, partly_dispatched, cancelled, error, missing_rate, on_hold")
    ext_ref: Optional[StrictStr] = Field(default=None, description="External ( hidden ) reference for the order. Used by system to update the order in e.g. order channels. Must be unique in scope of order channels.")
    visible_ref: Optional[StrictStr] = Field(default=None, description="Visible reference - the friendly/visible external order number")
    drop_point: Optional[DropPoints] = None
    original_shipping: Optional[Union[str, Any]] = Field(default=None, description="Flattened resource describing the original shipping option from the order channel. This will be used for matching in cases where shipping was not quoted from Webshipper.")
    order_lines: Optional[List[OrderLines]] = Field(default=None, description="Flattened resource of type OrderLine")
    delivery_address: Optional[ShippingAddresses] = None
    sender_address: Optional[ShippingAddresses] = None
    billing_address: Optional[ShippingAddresses] = None
    sold_from_address: Optional[ShippingAddresses] = None
    currency: Optional[StrictStr] = Field(default=None, description="Currency code of the order")
    internal_comment: Optional[StrictStr] = Field(default=None, description="Latest comment with type 'internal'. Changing this, will create a new comment")
    external_comment: Optional[StrictStr] = Field(default=None, description="External order comment. Will typically be the order comment from e-commerce checkout.")
    error_message: Optional[Union[str, Any]] = Field(default=None, description="Any error message that resulted from the latest attempt at making a shipment from the order.")
    slip: Optional[StrictStr] = Field(default=None, description="The order slip in PDF format using base64 encoding. This will only be included if the parameter fields[orders] includes slip.")
    var_base64: Optional[StrictStr] = Field(default=None, alias="base64")
    updated_at: Optional[StrictStr] = Field(default=None, description="The time when resource was last updated or when it was created if it was never updated")
    created_at: Optional[StrictStr] = Field(default=None, description="The time when the resource was created")
    lock_state: Optional[StrictStr] = Field(default=None, description="When an order is locked, it cannot be modified or sent until it is unlocked. Possible values: <code>locked</code> or <code>unlocked</code>.")
    source: Optional[StrictStr] = Field(default=None, description="A description of how the order was created in Webshipper. Possible values: 'api', 'manual' or 'csv'")
    tags: Optional[List[StrictStr]] = Field(default=None, description="Array of strings used to tag an order")
    error_class: Optional[StrictStr] = Field(default=None, description="A string like 'address' or 'carrier_downtime' describe which type of error caused the order to fail")
    slip_printed: Optional[StrictBool] = None
    label_printed: Optional[StrictBool] = None
    create_shipment_automatically: Optional[StrictStr] = None
    latest_activity: Optional[StrictStr] = None
    latest_status_event: Optional[StrictStr] = None
    shipping_rate_id: Optional[StrictInt] = None
    csv_upload_id: Optional[StrictInt] = None
    __properties: ClassVar[List[str]] = ["order_channel_id", "status", "ext_ref", "visible_ref", "drop_point", "original_shipping", "order_lines", "delivery_address", "sender_address", "billing_address", "sold_from_address", "currency", "internal_comment", "external_comment", "error_message", "slip", "base64", "updated_at", "created_at", "lock_state", "source", "tags", "error_class", "slip_printed", "label_printed", "create_shipment_automatically", "latest_activity", "latest_status_event", "shipping_rate_id", "csv_upload_id"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of Orders from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
                "slip",
                "var_base64",
                "updated_at",
                "created_at",
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of drop_point
        if self.drop_point:
            _dict['drop_point'] = self.drop_point.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in order_lines (list)
        _items = []
        if self.order_lines:
            for _item in self.order_lines:
                if _item:
                    _items.append(_item.to_dict())
            _dict['order_lines'] = _items
        # override the default output from pydantic by calling `to_dict()` of delivery_address
        if self.delivery_address:
            _dict['delivery_address'] = self.delivery_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sender_address
        if self.sender_address:
            _dict['sender_address'] = self.sender_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of billing_address
        if self.billing_address:
            _dict['billing_address'] = self.billing_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sold_from_address
        if self.sold_from_address:
            _dict['sold_from_address'] = self.sold_from_address.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of Orders from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "order_channel_id": obj.get("order_channel_id"),
            "status": obj.get("status"),
            "ext_ref": obj.get("ext_ref"),
            "visible_ref": obj.get("visible_ref"),
            "drop_point": DropPoints.from_dict(obj.get("drop_point")) if obj.get("drop_point") is not None else None,
            "original_shipping": obj.get("original_shipping"),
            "order_lines": [OrderLines.from_dict(_item) for _item in obj.get("order_lines")] if obj.get("order_lines") is not None else None,
            "delivery_address": ShippingAddresses.from_dict(obj.get("delivery_address")) if obj.get("delivery_address") is not None else None,
            "sender_address": ShippingAddresses.from_dict(obj.get("sender_address")) if obj.get("sender_address") is not None else None,
            "billing_address": ShippingAddresses.from_dict(obj.get("billing_address")) if obj.get("billing_address") is not None else None,
            "sold_from_address": ShippingAddresses.from_dict(obj.get("sold_from_address")) if obj.get("sold_from_address") is not None else None,
            "currency": obj.get("currency"),
            "internal_comment": obj.get("internal_comment"),
            "external_comment": obj.get("external_comment"),
            "error_message": obj.get("error_message"),
            "slip": obj.get("slip"),
            "base64": obj.get("base64"),
            "updated_at": obj.get("updated_at"),
            "created_at": obj.get("created_at"),
            "lock_state": obj.get("lock_state"),
            "source": obj.get("source"),
            "tags": obj.get("tags"),
            "error_class": obj.get("error_class"),
            "slip_printed": obj.get("slip_printed"),
            "label_printed": obj.get("label_printed"),
            "create_shipment_automatically": obj.get("create_shipment_automatically"),
            "latest_activity": obj.get("latest_activity"),
            "latest_status_event": obj.get("latest_status_event"),
            "shipping_rate_id": obj.get("shipping_rate_id"),
            "csv_upload_id": obj.get("csv_upload_id")
        })
        return _obj


